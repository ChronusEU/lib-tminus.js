{"version":3,"sources":["src/lib.ts","lib-tminus.min.js","node_modules/class-list/index.js","node_modules/class-list/node_modules/indexof/index.js","src/countdown/Countdown.ts","src/countdown/Looper.ts","src/countdown/RAFLooper.ts","src/countdown/TimeoutLooper.ts","src/parser/AttributeTemplateParser.ts","src/unit/Instant.ts","src/unit/Period.ts","src/util/copyMap.ts","src/util/epoch.ts","src/util/foreach.ts","src/util/prefixed.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","TminusLib","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"_dereq_","convertToArray","input","isArrayLike","createCountdown","milliSeconds","roots","options","rootArray","oldFinishedCallback","finishedCallback","clazz","finishedClass","DEFAULT_FINISHED_CLASS","forEach","elem","ClassList","add","loadingClass","oldLoadedCallback","loadedCallback","remove","parser","ATParser","AttributeTemplateParser","Countdown","create","Date","build","countdown","opts","Number","endTime","target","./countdown/Countdown","./parser/AttributeTemplateParser","./util/foreach","class-list",2,"token","list","getTokens","indexof","push","setTokens","index","splice","contains","toggle","$toString","className","item","tokens","filter","split","isTruthy","join","classList","cl","toString","arr","fn","ret","value",3,"indexOf","obj",4,"generateToString","endInstant","getPeriod","looper","toDate","toSeconds","isRunning","endDate","updater","Instant","make","isValid","periodBuilder","epoch","until","prevPeriod","Period","ofMillis","MAX_VALUE","Looper","period","eq","isFinished","start","currentPeriod","lastUpdate","stop","../unit/Instant","../unit/Period","../util/epoch","./Looper",5,"cb","RAFLooper","isAvailable","TimeoutLooper","./RAFLooper","./TimeoutLooper",6,"prefixed","rAF","cAF","RAF_ENABLED","RequestAnimationFrame","handle","prototype","_this","../util/prefixed",7,"pSetInterval","pClearInterval","TIMEOUT_60_FPS_IN_MS","Math","floor",8,"zeroPad","num","noopZeroPad","removeArrayIndexes","indexesToRemove","sort","buildUpdater","key","zeroPadFunc","dElem","hElem","insignificantHandler","previousValue","NaN","el","style","display","unit","getUnit","paddedValue","innerHTML","significant","TimeKey","copyMap","DOM_DISPLAY_ATTRIBUTE","DOM_HIDABLE_ATTRIBUTE","DEFAULT_KEY_PADDING","S","m","M","h","H","D","kDisplay","displayAttribute","kHidable","hidableAttribute","padKeys","zeroPadOverrides","Object","keys","undefined","displayElements","hidableElements","querySelectorAll","updaters","getAttribute","els","p","toRemove","../util/copyMap","../util/foreach",9,"isNaN","isFinite","otherInstant","date","getTime","./Period",10,"extractUnit","seconds","parentBoundary","stepSize","ofSeconds","SECOND_IN_SECONDS","MINUTE_IN_SECONDS","HOUR_IN_SECONDS","DAY_IN_SECONDS","INFINITE_SECONDS","max","k",11,"original","./foreach",12,"now",13,"array","callback","scope",14,"capitalizeName","name","charAt","toUpperCase","slice","findPrefixedObject","unprefixedName","prefixesLen","tmp","VENDOR_PREFIXES","Prefixed","str","windowRef","FUNCTION_BIND_AVAILABLE","bind","Function"],"mappings":"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","file":"lib-tminus.min.js","sourcesContent":["/// <reference path=\"./decl/class-list.d.ts\" />\r\n/// <reference path=\"./decl/ArrayLike.d.ts\" />\r\n'use strict';\r\n\r\nimport ClassList = require(\"class-list\");\r\nimport forEach = require(\"./util/foreach\");\r\nimport Countdown = require('./countdown/Countdown');\r\nimport Period = require('./unit/Period');\r\nimport Parser = require('./parser/Parser');\r\nimport ATParser = require('./parser/AttributeTemplateParser');\r\n\r\nvar DEFAULT_FINISHED_CLASS:string = \"finished\";\r\n\r\n/**\r\n * This function coerces the given type to an array-like type.\r\n *\r\n * If: input is array-indexable (has .length property)\r\n *   => returns without change\r\n * Else:\r\n *   => return input wrapped in an Array\r\n */\r\nfunction convertToArray<U>(input:U|ArrayLike<U>):ArrayLike<U> {\r\n    //Implementation based on jQuery's core.isArrayLike\r\n    var length = \"length\" in input && (<ArrayLike<U>>input).length;\r\n    var isArrayLike = typeof input === \"array\"\r\n        || length === 0\r\n        || typeof length === \"number\"\r\n        && length > 0\r\n        && ( length - 1 ) in input;\r\n\r\n    if (isArrayLike) {\r\n        return <ArrayLike<U>>input;\r\n    } else {\r\n        return [<U>input];\r\n    }\r\n}\r\n\r\nexport interface LibOptions extends Countdown.Options, Parser.ParserOptions {\r\n    /**\r\n     * Class name that should be added to the provided root elements once the countdown has finished.\r\n     *\r\n     * Defaults to {@see DEFAULT_FINISHED_CLASS}\r\n     */\r\n    finishedClass?: string\r\n\r\n    /**\r\n     * Class name that should be removed from the provided root elements once the countdown has initialized.\r\n     */\r\n    loadingClass?: string\r\n}\r\n\r\nexport interface InputOptions extends LibOptions {\r\n    /**\r\n     * Instant that the countdown will be counting down to.\r\n     *\r\n     * Accepts either a Date instance or milliseconds since UNIX epoch (1st Jan 1970 00:00 UTC)\r\n     */\r\n    endTime: number|Date\r\n\r\n    /**\r\n     * DOM element(s) that will be injected with the countdown.\r\n     *\r\n     * By default the {@see AttributeTemplateParser} is used to determine the format of the countdown.\r\n     * This parser uses data contained in the pre-existing DOM tree of the targets to inject the countdown.\r\n     */\r\n    target: HTMLElement|ArrayLike<HTMLElement>\r\n}\r\n\r\n/**\r\n * The default behaviour has the following steps:\r\n * * Add default behavior for adding a 'finished' class to the roots once finished.\r\n * * If specified, add callback to remove 'loading' class from roots.\r\n * * Create a \"data-*\"-based parser with the given options.\r\n * * Parse the given roots with the parser and create the countdown looper.\r\n * * Return the controls for the created looper.\r\n */\r\nfunction createCountdown(milliSeconds:number,\r\n                         roots:HTMLElement|ArrayLike<HTMLElement>,\r\n                         options:LibOptions):Countdown.Controller {\r\n    var rootArray = convertToArray(roots);\r\n\r\n    //Default behavior, add class on finish\r\n    var oldFinishedCallback = options.finishedCallback;\r\n    options.finishedCallback = () => {\r\n        var clazz = options.finishedClass || DEFAULT_FINISHED_CLASS;\r\n\r\n        //Add class to all root elements\r\n        forEach(rootArray, (elem:HTMLElement) => {\r\n            ClassList(elem).add(clazz);\r\n        });\r\n\r\n        //If there was a callback, invoke it\r\n        if (oldFinishedCallback) {\r\n            oldFinishedCallback();\r\n        }\r\n    };\r\n\r\n    //Default behavior, remove loading class once loaded\r\n    if (options.loadingClass) {\r\n        var oldLoadedCallback = options.loadedCallback;\r\n        options.loadedCallback = () => {\r\n            //Remove loading class from all root elements\r\n            forEach(rootArray, (elem:HTMLElement) => {\r\n                ClassList(elem).remove(options.loadingClass);\r\n            });\r\n\r\n            //Invoke the old callback, if it exists.\r\n            if (oldLoadedCallback) {\r\n                oldLoadedCallback();\r\n            }\r\n        };\r\n    }\r\n\r\n    var parser:Parser.Parser = new ATParser.AttributeTemplateParser(options);\r\n    return Countdown.create(new Date(milliSeconds), parser.build(rootArray), options);\r\n}\r\n\r\n/**\r\n * Entry point for the library, initializes a countdown using the target DOM and moment specified in the options.\r\n */\r\nexport function countdown(opts:InputOptions):Countdown.Controller {\r\n    return createCountdown(Number(opts.endTime), opts.target, opts)\r\n}",null,"// contains, add, remove, toggle\nvar indexof = require('indexof')\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (indexof(list, token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = indexof(list, token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return indexof(getTokens(), token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return filter(className.split(\" \"), isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction filter (arr, fn) {\n    var ret = []\n    for (var i = 0; i < arr.length; i++) {\n        if (fn(arr[i])) ret.push(arr[i])\n    }\n    return ret\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};","'use strict';\r\n\r\nimport Looper = require('./Looper');\r\nimport Period = require('../unit/Period');\r\nimport Instant = require('../unit/Instant');\r\nimport epoch = require('../util/epoch');\r\n\r\nexport interface Options {\r\n    /**\r\n     * Function that will be called once the countdown has reached zero.\r\n     *\r\n     * It is guaranteed to be called, even if the associated countdown has already reached zero when it begins.\r\n     */\r\n    finishedCallback?: () => any;\r\n\r\n    /**\r\n     * Function that will be called once the countdown has been constructed and started.\r\n     *\r\n     * There is no guarantee that this callback will fire before the finishedCallback.\r\n     */\r\n    loadedCallback?: () => any;\r\n}\r\n\r\nexport interface Controller {\r\n    /**\r\n     * Returns a period that is always equal to the amount of time left until the countdown ends.\r\n     */\r\n    currentPeriod(): Period.Period;\r\n\r\n    /**\r\n     * Returns the last period for which the actual countdown has been updated.\r\n     *\r\n     * If the window is hidden or in a tab then this value might not reflect the actual progress of the countdown,\r\n     * use {@see Controller#currentPeriod} if the returned value should always be up to date.\r\n     */\r\n    lastUpdate(): Period.Period;\r\n\r\n    /**\r\n     * Stop the countdown, once it has been stopped it will no longer fire the updater or update its internal period.\r\n     *\r\n     * If the countdown has already stopped this method will do nothing.\r\n     */\r\n    stop(): void;\r\n\r\n    /**\r\n     * Starts a previously stopped countdown, it will retain all the state from before it was stopped.\r\n     *\r\n     * If the countdown is already running, the only effect of this method will be a forced call to the updater.\r\n     */\r\n    start(): void;\r\n}\r\n\r\n//Utility function to generate the toString function for the Controller\r\nfunction generateToString(endInstant:Instant, getPeriod:()=> Period.Period, looper: Looper.Looper):()=>string {\r\n    return () => {\r\n        return `Countdown{` +\r\n            `until=${endInstant.toDate()},` +\r\n            `timeLeft=${getPeriod().toSeconds()}s,` +\r\n            `active=${looper.isRunning()}`+\r\n            `}`;\r\n    };\r\n}\r\n\r\nexport type Updater = (period:Period.Period) => any;\r\n\r\n/**\r\n * Constructs a countdown loop that will call the provided updater function each time the countdown changes.\r\n *\r\n * When the endDate is reached the countdown will automatically stop itself,\r\n * it will always call the updater at least once.\r\n *\r\n * If milliseconds are required for the countdown then this should be done externally.\r\n * The reason milliseconds are not used is that they change too rapidly to actually be useful,\r\n * a similar effect to an actual millisecond countdown can be reached with visual tricks.\r\n *\r\n * @param {Date} endDate moment that we will be counting down to.\r\n * @param {Function} updater function which will be called each time a new period is available.\r\n * @param {object} opts callback options to track some of the progress of the countdown.\r\n * @throws If the provided endDate is not a valid date.\r\n */\r\nexport function create(endDate:Date, updater:Updater, opts:Options):Controller {\r\n    var endInstant = Instant.make(endDate);\r\n\r\n    if (endInstant.isValid()) {\r\n        var periodBuilder = () => {\r\n            return Instant.make(epoch()).until(endInstant);\r\n        };\r\n\r\n        var prevPeriod = Period.ofMillis(Number.MAX_VALUE);\r\n\r\n        var looper = Looper.make(() => {\r\n            var period = periodBuilder();\r\n\r\n            if (!period.eq(prevPeriod)) {\r\n                prevPeriod = period;\r\n\r\n                updater(period);\r\n\r\n                if (period.isFinished() && opts.finishedCallback) {\r\n                    opts.finishedCallback();\r\n                }\r\n            }\r\n\r\n            return !period.isFinished();\r\n        });\r\n\r\n        //Begin the countdown\r\n        looper.start();\r\n\r\n        if (opts.loadedCallback) {\r\n            opts.loadedCallback();\r\n        }\r\n\r\n        return {\r\n            currentPeriod: periodBuilder,\r\n            lastUpdate: () => {\r\n                return prevPeriod;\r\n            },\r\n            stop: () => {\r\n                looper.stop();\r\n            },\r\n            start: () => {\r\n                //By setting prevPeriod, we force the updater to be called.\r\n                prevPeriod = Period.ofMillis(Number.MAX_VALUE);\r\n                looper.start();\r\n            },\r\n            toString: generateToString(endInstant, periodBuilder, looper)\r\n        }\r\n    } else {\r\n        throw new Error(\"Invalid target date passed to countdown\");\r\n    }\r\n}","'use strict';\r\n\r\nimport RAFLooper = require('./RAFLooper');\r\nimport TimeoutLooper = require('./TimeoutLooper');\r\n\r\n/**\r\n * A looper is a controllable construct that is able to invoke a callback at a regular interface.\r\n *\r\n * The rate of invocation should not be relied upon and is not strictly defined.\r\n */\r\nexport interface Looper {\r\n    /**\r\n     * Start invoking the callback at a specified interval.\r\n     *\r\n     * Once this function returns {@see isRunning} will need to return true.\r\n     */\r\n    start(): void;\r\n\r\n    /**\r\n     * Stops any future invocation of the callback.\r\n     *\r\n     * Once this function returns {@see isRunning} will need to return false.\r\n     */\r\n    stop(): void;\r\n\r\n    /**\r\n     * Queries the current state of the looper.\r\n     *\r\n     * If it returns true then the callback will be called at least once in the future\r\n     */\r\n    isRunning(): boolean;\r\n}\r\n\r\n/**\r\n * Utility function to construct an object that implements the Looper interface and invokes the provided callback.\r\n *\r\n * Will attempt to use a RequestAnimationFrame-based Looper, falling back to a\r\n * Timeout-based Looper if RAF is not available.\r\n *\r\n * If the callback returns false then the Looper will stop any future invocations of the callback.\r\n *\r\n * @param cb callback that will be repeatedly invoked by the returned Looper.\r\n */\r\nexport function make(cb:() => boolean):Looper {\r\n    if (RAFLooper.isAvailable()) {\r\n        return new RAFLooper(cb);\r\n    } else {\r\n        return new TimeoutLooper(cb);\r\n    }\r\n}","'use strict';\r\n\r\nimport prefixed = require('../util/prefixed');\r\nimport Looper = require('./Looper');\r\n\r\n// Retrieve (potentially vendor-prefixed) requestAnimationFrame and\r\n// cancelAnimationFrame methods\r\ntype RAFType = (cb:FrameRequestCallback) => number;\r\ntype CAFType = (handle:number) => void;\r\nvar rAF = prefixed<RAFType>('requestAnimationFrame');\r\nvar cAF = prefixed<CAFType>('cancelAnimationFrame') || prefixed<CAFType>('cancelRequestAnimationFrame');\r\n\r\nvar RAF_ENABLED = typeof rAF !== \"undefined\";\r\n\r\n/**\r\n * Looper based on the HTML-5 RequestAnimationFrame API.\r\n *\r\n * This looper has the property that it will not be called if the browser page is hidden in some way, since it gets\r\n * executed before each redraw of the page.\r\n */\r\nclass RequestAnimationFrame implements Looper.Looper {\r\n    private handle:number;\r\n\r\n    /**\r\n     * Create a RAF-based Looper that will invoke the given callback.\r\n     *\r\n     * If the callback returns false, the Looper will cancel any future invocations.\r\n     *\r\n     * @param {Function} cb callback that will be invoked by this looper.\r\n     */\r\n    constructor(private cb:() => boolean) {\r\n        this.handle = -1;\r\n    }\r\n\r\n    start():void {\r\n        //Make sure we aren't already running\r\n        if (this.isRunning()) return;\r\n\r\n        //function keeps requesting the next frame until\r\n        //the callback returns false\r\n        var fn = () => {\r\n            if (this.cb() !== false) {\r\n                this.handle = rAF(fn);\r\n            }\r\n        };\r\n\r\n        //Jump-start the loop\r\n        fn();\r\n    }\r\n\r\n    stop():void {\r\n        if (!this.isRunning()) return;\r\n\r\n        //Clear request and reset handle\r\n        cAF(this.handle);\r\n        this.handle = -1;\r\n    }\r\n\r\n    isRunning():boolean {\r\n        return this.handle != -1;\r\n    }\r\n\r\n    /**\r\n     * Determines whether the current environment supports update loops based on frame refreshes.\r\n     *\r\n     * If this method returns false, the RequestAnimationFrame-based Looper will fail to work.\r\n     */\r\n    static isAvailable():boolean {\r\n        return RAF_ENABLED;\r\n    }\r\n}\r\n\r\nexport = RequestAnimationFrame;","'use strict';\r\n\r\nimport prefixed = require('../util/prefixed');\r\nimport Looper = require('./Looper');\r\n\r\nvar pSetInterval = prefixed<(handler:any, timeout?:any, ...args:any[])=>number>('setInterval');\r\nvar pClearInterval = prefixed<(handle:number)=>void>('clearInterval');\r\n\r\nvar TIMEOUT_60_FPS_IN_MS = Math.floor(1000 / 60);\r\n\r\n/**\r\n * This Looper uses the setInterval/clearInterval API as its implementation.\r\n *\r\n * The interval at which the function is called is set to {@see TIMEOUT_60_FPS_IN_MS}\r\n *\r\n * If a window is hidden then most browsers will limit the rate of invocation of this Looper to once every second.\r\n */\r\nclass TimeoutLooper implements Looper.Looper {\r\n    private handle:number;\r\n\r\n    /**\r\n     * Create a setInterval-based Looper that will invoke the given callback.\r\n     *\r\n     * If the callback returns false, the Looper will cancel any future invocations.\r\n     *\r\n     * @param {Function} cb callback that will be invoked by this looper.\r\n     */\r\n    constructor(private cb:() => boolean) {\r\n        this.handle = -1;\r\n    }\r\n\r\n    start():void {\r\n        //Make sure we aren't already running\r\n        if (this.isRunning()) return;\r\n\r\n        if (this.cb() !== false) {\r\n            this.handle = pSetInterval(() => {\r\n                if (this.cb() === false) {\r\n                    this.stop();\r\n                }\r\n            }, TIMEOUT_60_FPS_IN_MS);\r\n        }\r\n    }\r\n\r\n    stop():void {\r\n        if (!this.isRunning()) return;\r\n\r\n        //Clear request and reset handle\r\n        pClearInterval(this.handle);\r\n        this.handle = -1;\r\n    }\r\n\r\n    isRunning():boolean {\r\n        return this.handle != -1;\r\n    }\r\n}\r\n\r\nexport = TimeoutLooper;","/// <reference path=\"../decl/ArrayLike.d.ts\" />\r\n/// <reference path=\"../decl/Dict.d.ts\" />\r\n'use strict';\r\n\r\nimport Parser = require('./Parser');\r\nimport Period = require('../unit/Period');\r\nimport copyMap = require('../util/copyMap');\r\nimport forEach = require('../util/foreach');\r\n\r\nexport type Callback = (period:Period.Period) => void;\r\n\r\nexport interface ATPOptions {\r\n    /**\r\n     * Data attribute that is used to identify which elements need to be injected by countdown components, as well as\r\n     * specify which type of component to inject.\r\n     *\r\n     * {@code <div data-{displayAttribute}=\"D\"></div>} will be injected with the amount of days left over for the\r\n     * countdown.\r\n     *\r\n     * The injection is performed by replacing the innerHTML of the tagged elements with the (possibly zero-padded)\r\n     * value, any previous content will be discarded.\r\n     *\r\n     * Defaults to {@see DOM_DISPLAY_ATTRIBUTE}\r\n     */\r\n    displayAttribute?: string;\r\n\r\n    /**\r\n     * Data attribute that is used to identify which elements need to be hidden once a specific countdown component\r\n     * becomes insignificant, as well as specify the exact component type to monitor for this event.\r\n     *\r\n     * For more information about significance {@link Period.TimeValue.significant}.\r\n     *\r\n     * {@code <div data-{hidableAttribute}=\"D\"></div>} will be hidden when the countdown has less than 1 day remaining.\r\n     *\r\n     * The element is hidden by setting the css attribute 'display' to 'none', essentially removing the element from\r\n     * the visual part of the DOM.\r\n     *\r\n     * Defaults to {@see DOM_HIDABLE_ATTRIBUTE}\r\n     */\r\n    hidableAttribute?: string;\r\n\r\n    /**\r\n     * Modify the default zero-padding behavior for the various {@link Period.TimeKey} components.\r\n     * If a key is set to true in this map, it will zero-pad the values in the template.\r\n     *\r\n     * Defaults to {@see DEFAULT_KEY_PADDING}\r\n     */\r\n    zeroPadOverrides?: Dict<boolean>;\r\n}\r\n\r\nvar DOM_DISPLAY_ATTRIBUTE:string = \"tminus-unit\";\r\nvar DOM_HIDABLE_ATTRIBUTE:string = \"tminus-hide-if-zero\";\r\n\r\n//Based on Period.TimeKey\r\nvar DEFAULT_KEY_PADDING:Dict<boolean> = {\r\n    \"s\": true,\r\n    \"S\": true,\r\n    \"m\": true,\r\n    \"M\": true,\r\n    \"h\": false,\r\n    \"H\": false,\r\n    \"D\": false\r\n};\r\n\r\n/**\r\n * If the given (positive) number is below 10, append a '0' before the number and return the string.\r\n */\r\nfunction zeroPad(num:number):string {\r\n    return num < 10 ? `0${num}` : `${num}`;\r\n}\r\n\r\n/**\r\n * Returns the given number as a string with no further modifications.\r\n */\r\nfunction noopZeroPad(num:number):string {\r\n    return `${num}`;\r\n}\r\n\r\n/**\r\n * Removes all the elements at the given indexes from the given array.\r\n * Both the indexes array and the target array will be modified by this function.\r\n *\r\n * @param arr Target array from which elements will be removed.\r\n * @param indexesToRemove Array indexes that need to be removed, cannot contain duplicate indexes.\r\n */\r\nfunction removeArrayIndexes<T>(arr:T[], indexesToRemove:number[]):void {\r\n    //Remove elements in reverse order, since splice\r\n    // changes the array length and element indexes\r\n    // for all items after the removed item.\r\n    indexesToRemove.sort();\r\n    for (var i = indexesToRemove.length; i--;) {\r\n        arr.splice(indexesToRemove[i], 1);\r\n    }\r\n}\r\n\r\nexport type SubCallback = (period:Period.Period) => boolean;\r\n\r\n/**\r\n * Creates an updater function for the given {@link Period.TimeKey}.\r\n *\r\n * This returned callback will not attempt to update the given elements if the Period that it is provided does not\r\n * differ from the previous Period.\r\n *\r\n * Once the {@link Period.TimeKey} has become insignificant, this updater will be deactivated since it no longer\r\n * needs to be updated.\r\n *\r\n * The created callback will return false when it no longer has to be called (due to being finished)\r\n */\r\nfunction buildUpdater(key:Period.TimeKey,\r\n                      zeroPadFunc:(n:number) => string,\r\n                      dElem:HTMLElement[],\r\n                      hElem:HTMLElement[],\r\n                      insignificantHandler:(el:HTMLElement[], key?:string)=>void):SubCallback {\r\n    var previousValue:number = Number.NaN;\r\n\r\n    if (dElem.length + hElem.length > 0) {\r\n        //Reset hidden values, will be corrected in the first iteration\r\n        forEach(hElem, (el) => el.style.display = \"\");\r\n\r\n        return (period:Period.Period) => {\r\n            var unit = period.getUnit(key);\r\n            if (unit.value !== previousValue) {\r\n                previousValue = unit.value;\r\n                var paddedValue = zeroPadFunc(previousValue);\r\n\r\n                forEach(dElem, (el:HTMLElement) => el.innerHTML = paddedValue);\r\n\r\n                // Once a value is no longer significant it cannot return,\r\n                // so the reverse case does not need to be handled\r\n                if (!unit.significant) {\r\n                    insignificantHandler(hElem, Period.TimeKey[key]);\r\n                }\r\n            }\r\n\r\n            return unit.significant;\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * The AttributeTemplateParser builds a countdown using a pre-existing DOM structure containing specific data-attribute\r\n * values to mark which elements need to be injected with values for the countdown.\r\n *\r\n * data-{opts.displayAttribute} specifies injection of countdown components. {@see Period.TimeKey}\r\n * data-{opts.hidableAttribute} specifies elements that need to be hidden once a countdown component becomes\r\n * insignificant.\r\n */\r\nexport class AttributeTemplateParser implements Parser.Parser {\r\n    private kDisplay:string;\r\n    private kHidable:string;\r\n    private padKeys:Dict<boolean>;\r\n\r\n    /**\r\n     * Construct a data-attribute-based parser with the given options.\r\n     *\r\n     * @param {object} opts options to modify some parsing behaviours.\r\n     */\r\n    constructor(opts:ATPOptions) {\r\n        this.kDisplay = opts.displayAttribute || DOM_DISPLAY_ATTRIBUTE;\r\n        this.kHidable = opts.hidableAttribute || DOM_HIDABLE_ATTRIBUTE;\r\n        this.padKeys = copyMap(DEFAULT_KEY_PADDING);\r\n\r\n        if (opts.zeroPadOverrides) {\r\n            forEach(Object.keys(opts.zeroPadOverrides), (key:string) => {\r\n                if (DEFAULT_KEY_PADDING[key] !== undefined) {\r\n                    this.padKeys[key] = opts.zeroPadOverrides[key];\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    build(roots:ArrayLike<HTMLElement>):Callback {\r\n        var displayElements:HTMLElement[] = [];\r\n        var hidableElements:HTMLElement[] = [];\r\n\r\n        forEach(roots, (el:HTMLElement) => {\r\n            forEach(\r\n                <NodeListOf<HTMLElement>>el.querySelectorAll(`[data-${this.kDisplay}]`),\r\n                (el) => displayElements.push(el)\r\n            );\r\n            forEach(\r\n                <NodeListOf<HTMLElement>>el.querySelectorAll(`[data-${this.kHidable}]`),\r\n                (el) => hidableElements.push(el)\r\n            );\r\n        });\r\n\r\n        var updaters:SubCallback[] = [];\r\n        forEach(Object.keys(this.padKeys), (key:string) => {\r\n            var updater = buildUpdater(\r\n                Period.TimeKey[key],\r\n                this.padKeys[key] ? zeroPad : noopZeroPad,\r\n                displayElements.filter((el) => el.getAttribute(`data-${this.kDisplay}`) === key),\r\n                hidableElements.filter((el) => el.getAttribute(`data-${this.kHidable}`) === key),\r\n                (els) => forEach(els, (el) => el.style.display = \"none\")\r\n            );\r\n\r\n            if (updater) {\r\n                updaters.push(updater);\r\n            }\r\n        });\r\n\r\n        return (p:Period.Period) => {\r\n            var toRemove:number[] = [];\r\n\r\n            forEach(updaters, (updater) => {\r\n                if (!updater(p)) {\r\n                    //Updater finished, queue for removal\r\n                    toRemove.push(updaters.indexOf(updater));\r\n                }\r\n            });\r\n\r\n            if (toRemove.length) {\r\n                //Remove the elements at the given indexes\r\n                removeArrayIndexes(updaters, toRemove);\r\n            }\r\n        };\r\n    }\r\n}","'use strict';\r\n\r\nimport Period = require('./Period');\r\n\r\n/**\r\n * An Instant represents an immutable point in time.\r\n *\r\n * It can represent any millisecond that is representable as an offset of Epoch time.\r\n */\r\nclass Instant {\r\n    /**\r\n     * Construct an instant for the given Epoch time.\r\n     *\r\n     * @constructor\r\n     * @param {number} epoch milliseconds since zero epoch (midnight UTC, 1st Jan 1970)\r\n     */\r\n    constructor(private epoch:number) {\r\n    }\r\n\r\n    /**\r\n     * Creates a javascript Date object that is equivalent to this instant in time.\r\n     *\r\n     * If this object is invalid {@see Instant#isValid}, the resulting date will be invalid as well.\r\n     */\r\n    toDate():Date {\r\n        return new Date(this.epoch);\r\n    }\r\n\r\n    /**\r\n     * Returns whether this instant represents a valid moment in time\r\n     */\r\n    isValid():boolean {\r\n        return (!isNaN(this.epoch)) && isFinite(this.epoch);\r\n    }\r\n\r\n    /**\r\n     * Calculates the period of time that has to elapse relative to this instant before it passes the reference instant.\r\n     *\r\n     * earlier.until(later) will result in the Period until that later point.\r\n     * later.until(earlier) will result in a zero Period, since the point in time has elapsed.\r\n     * same.until(same) will return a zero Period.\r\n     *\r\n     * @param {Instant} otherInstant reference point to some future instant\r\n     */\r\n    until(otherInstant:Instant):Period.Period {\r\n        return Period.ofMillis(otherInstant.epoch - this.epoch);\r\n    }\r\n\r\n    /**\r\n     * Create a new Instant that is offset from this Instant by the given Period.\r\n     *\r\n     * This method follow the following contract: Instant.until(Instant.add(Period)).eq(Period)\r\n     *\r\n     * @param {Period} period offset of the returned Instant relative to this Instant\r\n     */\r\n    add(period:Period.Period):Instant {\r\n        return Instant.make(this.epoch + period.toSeconds() * 1000);\r\n    }\r\n\r\n    /**\r\n     * Factory method to create new Instant objects using either the number of milliseconds since zero epoch or\r\n     * a javascript Date object.\r\n     *\r\n     * @param {number|Date} date point in time that the new Instant will refer to.\r\n     */\r\n    static make(date:number|Date):Instant {\r\n        if (typeof date === \"number\") {\r\n            return new Instant(date);\r\n        } else {\r\n            return new Instant(date.getTime());\r\n        }\r\n    }\r\n}\r\n\r\nexport = Instant;","'use strict';\r\n\r\n/**\r\n * Enum which represents all the time units that can be derived from a Period\r\n *\r\n * Uppercase time units are absolute\r\n * Lowercase time units are relative to their parent units (e.g. minutes until last hour)\r\n *\r\n * Currently supported units: Seconds, Minutes, Hours and Days.\r\n *\r\n * @see {Period#getUnit}\r\n */\r\nexport enum TimeKey\r\n{\r\n    s, // seconds until next minute\r\n    S, // seconds until zero\r\n    m, // minutes until next hour\r\n    M, // minutes until zero\r\n    h, // hours until next day\r\n    H, // hours until zero\r\n    D  // days until zero\r\n}\r\n\r\nexport interface TimeValue {\r\n    /**\r\n     * Value of the instant with the given reference point. (Absolute or Relative, see TimeKey)\r\n     */\r\n    value:number;\r\n\r\n    /**\r\n     * Whether the value is still significant, a value becomes non-significant if it passes a point where it\r\n     * will ever be non-zero assuming the period only decreases.\r\n     */\r\n    significant:boolean;\r\n}\r\n\r\n/**\r\n * Utility method to convert a Period in seconds into another unit of time.\r\n *\r\n * @param {number} seconds number of seconds to convert from.\r\n * @param {number} parentBoundary number of seconds at which the unit becomes another unit, acts as modulo.\r\n * @param {number} stepSize number of seconds for 1 unit.\r\n */\r\nfunction extractUnit(seconds:number, parentBoundary:number, stepSize:number):TimeValue {\r\n    return {value: Math.floor((seconds % parentBoundary) / stepSize), significant: seconds >= stepSize};\r\n}\r\n\r\nvar SECOND_IN_SECONDS = 1;\r\nvar MINUTE_IN_SECONDS = SECOND_IN_SECONDS * 60;\r\nvar HOUR_IN_SECONDS = MINUTE_IN_SECONDS * 60;\r\nvar DAY_IN_SECONDS = HOUR_IN_SECONDS * 24;\r\n//Infinite for the purposes of this library\r\nvar INFINITE_SECONDS = Number.MAX_VALUE;\r\n\r\n/**\r\n * A period represents an immutable positive length of time in seconds.\r\n *\r\n * This class has a number of methods to convert its length to different time scales,\r\n * see {@see Period#getUnit} for more information.\r\n */\r\nexport class Period {\r\n    private seconds:number;\r\n\r\n    /**\r\n     * Create a period for the given length in seconds.\r\n     * If the given length is negative it will be treated as if it was zero.\r\n     *\r\n     * @constructor\r\n     * @param {number} seconds length of this period\r\n     */\r\n    constructor(seconds:number) {\r\n        this.seconds = Math.max(seconds, 0);\r\n    }\r\n\r\n    /**\r\n     * A period with a length that is above zero will not be finished, any other lengths will be finished.\r\n     */\r\n    isFinished():boolean {\r\n        return this.seconds <= 0;\r\n    }\r\n\r\n    /**\r\n     * Alias for Period.getUnit(TimeKey.S).value\r\n     *\r\n     * Returns the total length of this period in seconds.\r\n     */\r\n    toSeconds():number {\r\n        return this.getUnit(TimeKey.S).value;\r\n    }\r\n\r\n    /**\r\n     * Method to convert this period into other units of time.\r\n     *\r\n     * See {@see TimeKey} for the supported time units.\r\n     * This method will return {@see TimeValue} describing the value in the given time unit.\r\n     *\r\n     * @param {string|number} key value key to convert to, see {@see TimeKey} for possible values.\r\n     */\r\n    getUnit(key:string|TimeKey):TimeValue {\r\n        var k:TimeKey;\r\n        if (typeof key === \"string\") {\r\n            k = TimeKey[key];\r\n        } else {\r\n            k = key;\r\n        }\r\n\r\n        var seconds = this.seconds;\r\n        switch (k) {\r\n            case TimeKey.s:\r\n                return extractUnit(seconds, MINUTE_IN_SECONDS, SECOND_IN_SECONDS);\r\n            case TimeKey.S:\r\n                return extractUnit(seconds, INFINITE_SECONDS, SECOND_IN_SECONDS);\r\n            case TimeKey.m:\r\n                return extractUnit(seconds, HOUR_IN_SECONDS, MINUTE_IN_SECONDS);\r\n            case TimeKey.M:\r\n                return extractUnit(seconds, INFINITE_SECONDS, MINUTE_IN_SECONDS);\r\n            case TimeKey.h:\r\n                return extractUnit(seconds, DAY_IN_SECONDS, HOUR_IN_SECONDS);\r\n            case TimeKey.H:\r\n                return extractUnit(seconds, INFINITE_SECONDS, HOUR_IN_SECONDS);\r\n            case TimeKey.D:\r\n                return extractUnit(seconds, INFINITE_SECONDS, DAY_IN_SECONDS);\r\n            default :\r\n                return <TimeValue>{value: NaN, significant: true};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines whether the given period is equal to this period in terms of length.\r\n     *\r\n     * @param period the other period\r\n     */\r\n    eq(period:Period):boolean {\r\n        return this.seconds === period.seconds;\r\n    }\r\n}\r\n\r\n/**\r\n * Factory method to create a period with a length equal to  the given number of milliseconds.\r\n *\r\n * Be aware that the period will be limited to a precision in seconds and will be limited to positive values.\r\n *\r\n * @param {number} milliSeconds length of the created period in milliseconds\r\n */\r\nexport function ofMillis(milliSeconds:number):Period {\r\n    return new Period(Math.floor(milliSeconds / 1000));\r\n}\r\n\r\n/**\r\n * Factory method to create a period with a length equal to the given number of seconds.\r\n *\r\n * Be aware that the period will be limited to positive values.\r\n *\r\n * @param {number} seconds length of the created period in seconds\r\n */\r\nexport function ofSeconds(seconds:number):Period {\r\n    return new Period(Math.floor(seconds));\r\n}","/// <reference path=\"../decl/Dict.d.ts\" />\r\n'use strict';\r\n\r\nimport forEach = require('./foreach');\r\n\r\n/**\r\n * Create a copy of the given key-value map.\r\n *\r\n * Only the enumerable properties that are owned by the given map are copied.\r\n * The prototype chain will not be copied.\r\n *\r\n * @param {object} original map to copy.\r\n */\r\nfunction copyMap<T>(original:Dict<T>):Dict<T> {\r\n    var ret:Dict<T> = {};\r\n\r\n    forEach(Object.keys(original), (key:string) => {\r\n        ret[key] = original[key];\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport = copyMap;","'use strict';\r\n\r\n/**\r\n * A utility function that returns the current number of seconds since zero epoch. (midnight UTC, 1st Jan 1970)\r\n *\r\n * This function is not implemented by the HTML5 performance API since the resolution is not required\r\n * and is it slower in practise than other methods: http://jsperf.com/current-date\r\n */\r\nvar epoch:() => number;\r\n\r\n//Attempt Date.now, otherwise use Date.getTime fallback\r\nif (typeof Date.now === \"function\") {\r\n    epoch = Date.now;\r\n} else {\r\n    epoch = () => {\r\n        return new Date().getTime();\r\n    }\r\n}\r\n\r\nexport = epoch;","/// <reference path=\"../decl/ArrayLike.d.ts\" />\r\n'use strict';\r\n\r\n/**\r\n * Utility function which will iterate through the given array and call the callback within the given scope.\r\n * Elements of the given array will provided to the callback in sequence.\r\n *\r\n * This method is used instead of {@see Array#forEach} since there are array-like structures which do not have\r\n * this method and calling the function through the prototype relies on implementation details.\r\n *\r\n * @param {Array} array array of values to iterate over\r\n * @param {Function} callback callback to call on each element\r\n * @param {object} scope scope to call the callback in, can be undefined.\r\n */\r\nfunction forEach<T>(array:ArrayLike<T>, callback:(value:T, index:number) => any, scope?:any):void {\r\n    var length = array.length;\r\n    for (var i = 0; i < length; i++) {\r\n        callback.call(scope, array[i], i);\r\n    }\r\n}\r\n\r\nexport = forEach;","'use strict';\r\n\r\nvar windowRef = window;\r\nvar FUNCTION_BIND_AVAILABLE = !!(Function.prototype.bind);\r\n\r\nvar VENDOR_PREFIXES:string[] = [\r\n    \"webkit\",\r\n    \"Webkit\",\r\n    \"ms\",\r\n    \"Moz\",\r\n    \"moz\",\r\n    \"O\",\r\n    \"o\",\r\n];\r\n\r\nvar prefixesLen = VENDOR_PREFIXES.length;\r\n\r\n/**\r\n * Capitalizes the first character of the given string\r\n */\r\nfunction capitalizeName(name:string):string {\r\n    return name.charAt(0).toUpperCase() + name.slice(1);\r\n}\r\n\r\n/**\r\n * Goes through the various vendor prefixes and attempts to find a property on the given object with a prefixed\r\n * variation of the given property name.\r\n *\r\n * Will return undefined if it cannot find any version of the property.\r\n */\r\nfunction findPrefixedObject<T>(name:string, obj:any):T {\r\n    if (name.length !== 0) {\r\n        var unprefixedName = capitalizeName(name);\r\n        for (var i = 0; i < prefixesLen; i++) {\r\n            var tmp = obj[VENDOR_PREFIXES[i] + unprefixedName];\r\n            if (typeof tmp !== \"undefined\") {\r\n                return tmp;\r\n            }\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Poor mans version of Modernizr.prefixed, it will attempt to find a potentially vendor-prefixed property on a given\r\n * object.\r\n *\r\n * @param {string} str name of the property to look for\r\n * @param {object} obj object in which the property will be searched for, if undefined will use the window object.\r\n * @param {object} scope if a function is found, it will be bound to this object before being returned.\r\n */\r\nfunction Prefixed<T>(str:string, obj:any = windowRef, scope:any = obj):T {\r\n    var target = obj[str];\r\n\r\n    if (typeof target === \"undefined\") {\r\n        //Attempt to find prefixed version\r\n        target = findPrefixedObject(str, obj);\r\n    }\r\n\r\n    if (typeof target === \"function\" && FUNCTION_BIND_AVAILABLE) {\r\n        return (<Function>target).bind(scope);\r\n    } else {\r\n        return target;\r\n    }\r\n}\r\n\r\nexport = Prefixed;"],"sourceRoot":"/source/"}